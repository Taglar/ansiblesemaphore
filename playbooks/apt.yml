---
# APT Update & Upgrade mit Locking, Backup, Cleanup und Logging
# Dieses Playbook f√ºhrt ein apt-Update/Upgrade durch, legt Backups ge√§nderter Konfigurationsdateien an,
# schreibt Logfiles und verhindert parallele Ausf√ºhrungen durch eine Lock-Datei.
# Alle Tasks laufen mit Root-Rechten (become: true).

- name: APT Update & Upgrade mit Locking, Backup, Cleanup und Logging
  hosts: LinuxUbuntu
  become: true
  gather_facts: true
  serial: 1

  vars:
    backup_root: "/var/backups"
    log_dir: "/var/log/ansible"
    lock_file: "{{ backup_root }}/apt_update.lock"

  # Preflight und globale Variablen
  pre_tasks:
    - name: Generiere globalen Zeitstempel
      run_once: true
      delegate_to: localhost
      set_fact:
        backup_date: "{{ lookup('pipe', 'date +%Y%m%dT%H%M%S') }}"

    - name: Setze host-spezifische Fakten
      set_fact:
        host_backup_dir: "{{ backup_root }}/apt_config_{{ backup_date }}/{{ inventory_hostname }}"
        root_backup_dir: "{{ backup_root }}/apt_config_{{ backup_date }}"
        log_file: "{{ log_dir }}/apt_update_{{ backup_date }}_{{ inventory_hostname }}.log"

  tasks:
    # Lock-Datei pr√ºfen und setzen
    - name: Pr√ºfe ob Lock existiert
      stat:
        path: "{{ lock_file }}"
      register: lock_stat

    - name: Abbruch bei aktivem Lock
      when: lock_stat.stat.exists
      fail:
        msg: "Lock-Datei {{ lock_file }} existiert bereits ‚Äì ein anderer Lauf ist aktiv."

    - name: Lock setzen
      file:
        path: "{{ lock_file }}"
        state: touch

    # Logging-Verzeichnis und Log-Datei anlegen
    - name: Stelle sicher, dass das Logging-Verzeichnis existiert
      file:
        path: "{{ log_dir }}"
        state: directory

    - name: Log-Datei initialisieren
      copy:
        dest: "{{ log_file }}"
        content: |
          === APT Update Log ===
          Host: {{ inventory_hostname }}
          Datum: {{ lookup('pipe', 'date') }}
          ======================
      notify: Log-Ergebnis anh√§ngen

    # Backup-Verzeichnisse anlegen
    - name: Stelle sicher, dass das Backup-Root existiert
      file:
        path: "{{ root_backup_dir }}"
        state: directory

    - name: Stelle sicher, dass das Host-Backup-Verzeichnis existiert
      file:
        path: "{{ host_backup_dir }}"
        state: directory

    # APT-Operationen
    - name: Aktualisiere Paketquellen (apt update)
      apt:
        update_cache: yes
      register: update_result

    - name: F√ºhre APT-Upgrade durch (dist-upgrade)
      apt:
        upgrade: dist
        autoremove: yes
        autoclean: yes
      register: upgrade_result

    # Kernel-Update und Reboot-Check
    - name: Pr√ºfe, ob Kernel-Update verf√ºgbar ist
      shell: |
        apt list --upgradable 2>/dev/null | grep -E 'linux-image|linux-headers' || true
      register: kernel_check
      changed_when: false

    - name: Pr√ºfe, ob Reboot notwendig ist
      stat:
        path: /var/run/reboot-required
      register: reboot_check

    - name: Setze Status-Fakten
      set_fact:
        kernel_update_available: "{{ kernel_check.stdout != '' }}"
        reboot_required: "{{ reboot_check.stat.exists | default(false) }}"

    # Neue oder ge√§nderte Konfigurationsdateien sichern
    - name: Suche nach neuen oder ge√§nderten Konfigurationsdateien
      find:
        paths: /etc
        patterns: "*.dpkg-dist"
      register: new_config_files

    - name: Sichere neue Dateien
      copy:
        src: "{{ item.path }}"
        dest: "{{ host_backup_dir }}/"
        remote_src: true
      loop: "{{ new_config_files.files }}"
      when: new_config_files.matched > 0

    - name: Pr√ºfe, ob Originaldateien existieren
      stat:
        path: "{{ item.path | regex_replace('.dpkg-dist$', '') }}"
      loop: "{{ new_config_files.files }}"
      register: original_files
      when: new_config_files.matched > 0

    - name: Sichere Originaldateien (falls vorhanden)
      copy:
        src: "{{ item.stat.path }}"
        dest: "{{ host_backup_dir }}/"
        remote_src: true
      loop: "{{ original_files.results }}"
      when:
        - original_files.results is defined
        - item.stat.exists is defined
        - item.stat.exists

    # Host-Backup-Verzeichnis entfernen, wenn keine Dateien gesichert wurden
    - name: Entferne Host-Backup-Verzeichnis, wenn leer
      file:
        path: "{{ host_backup_dir }}"
        state: absent
      when: new_config_files.matched | default(0) == 0

    # Zusammenfassung und Logging
    - name: Zusammenfassung ausgeben
      debug:
        msg:
          - "‚úÖ Paketquellen aktualisiert"
          - "‚úÖ Pakete aktualisiert"
          - "‚úÖ Autoremove/Autoclean ausgef√ºhrt"
          - "{{ '‚ôªÔ∏è  Neustart erforderlich' if reboot_required else '‚ÑπÔ∏è  Kein Neustart n√∂tig' }}"
          - "{{ 'üß© Kernel-Update verf√ºgbar' if kernel_update_available else '‚úÖ Kernel aktuell' }}"
          - "Backups abgelegt unter: {{ host_backup_dir if new_config_files.matched > 0 else 'kein Backup n√∂tig' }}"
          - "Logfile: {{ log_file }}"

    - name: Log-Ergebnis anh√§ngen
      lineinfile:
        path: "{{ log_file }}"
        line: |
          Update: {{ update_result.changed }}, Upgrade: {{ upgrade_result.changed }}, Neustart erforderlich: {{ reboot_required }}, Kernel-Update: {{ kernel_update_available }}, Backups: {{ new_config_files.matched | default(0) }} Dateien
        create: yes

  # Handler f√ºr Logdateien
  handlers:
    - name: Log-Ergebnis anh√§ngen
      # Platzhalter-Handler, wird durch Notify aufgerufen ‚Äì Inhalt oben definiert
      debug:
        msg: ""

  # Lock entfernen ‚Äì immer ausf√ºhren
  post_tasks:
    - name: Entferne Lock-Datei
      file:
        path: "{{ lock_file }}"
        state: absent
